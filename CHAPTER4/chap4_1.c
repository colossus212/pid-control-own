/****************************************************************************************
*	
*	单神经元自适应PID控制
*
*		单神经元自适应控制器是通过对加权系数的调整来实现自适应、自组织功能，权系数的调整
*	是按监督的Hebb学习规则实现的。
*
*	注：因算法本身的复杂度问题，该程序未整定完全，具体参数和计算方式请根据实际情况定义！
****************************************************************************************/

#include <math.h>


//K：神经元比例系数，越大快速性越好，但易引起超调量过大，导致系统不稳定
#define K  0.06


//学习率、权重的初始化random
float xite_p=0.40,xite_i=0.35,xite_d=0.40;//学习率初始化
float wk_p[3]={0.10,0.10,0.10},wk_i[3]={0.10,0.10,0.10},wk_d[3]={0.10,0.10,0.10};//权重初始化
float w11[3]={0,0,0},w22[3]={0,0,0},w33[3]={0,0,0};
float x_1=0,x_2=0,x_3=0;
float error=0,error_1=0,error_2=0;
float wadd=0;
float range[3]={20,3,3};


/********************************************************
  rin  ：传入的控制量/设定量（可经过公式转换为控制效果，理想姿态量），我们想要达到的目标值
  yout ：我们实际得到的控制效果（检测到的姿态量）
  pid[]：经过自适应神经元迭代得出的PID量
*********************************************************/
void snn_get_pid(float rin,float yout,float *pid)
{
	
	int i=0;
	
	//误差计算
	
	
	error = rin - yout;

	for(i=0;i<3;i++)
	{	
		//PID权重值的调整
		wk_p[i] = wk_p[i] + xite_p*pid[i]*x_1;
		wk_i[i] = wk_i[i] + xite_i*pid[i]*x_2;
		wk_d[i] = wk_d[i] + xite_d*pid[i]*x_3;
	}
	
	//增量式PID误差计算
	x_1 = error - error_1;
	x_2 = error;
	x_3 = error - 2*error_1 + error_2;
	
	for(i=0;i<3;i++)
	{
		//归一化处理
		wadd[i] = fabs(wk_p[i]) + fabs(wk_i[i]) + fabs(wk_d[i]);
		w11[i]=wk_p[i]/wadd[i];
		w22[i]=wk_i[i]/wadd[i];
		w33[i]=wk_d[i]/wadd[i];
	
		//计算出新的控制量
		pid[i] = pid[i] + K*(w11[i]*x_1 + w22[i]*x_2 + w33[i]*x_3);
		
		//参数范围的限制
		if(pid[i] > range[i])
			pid[i] = range[i];
		else if(pid[i] < ((-1)*range[i]))
			pid[i] = (-1)*range[i];
	
	}
	
	//迭代更新
	error_2 = error_1;
	error_1 = error;
}